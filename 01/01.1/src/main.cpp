
/* Compute mean and variance of r generated by random.Rannyu()
 * and run a chi^2 test to verify if it's uniformly distributed in [0;1)
 * 
 * Usage
 * ---------
 * ./main <output_mean> <output_variance> <output_chi2>
 * 
 * Output
 * ---------
 * output_mean, output_variance: each row refers to a block of the block 
 * averaging algorithm and has two columns indicating, respectively, 
 * the last estimate of the value computed and its statistical uncertainty
 * 
 * output_chi2: each row contains the chi^2 value obtained from a different
 * chi^2 test
 */

#include <iostream>
#include <fstream>
#include <string>
#include <cmath>
#include "random.h"
#include "utils.h"

#define M 100000    //number of iterations in mean and variance computation
#define N 100       //number of blocks in mean and variance computation

#define K 100       //subintervals of (0,1) used in chi^2 test
#define R 100000     //number of extraction for each chi^2 test
#define N_TEST 100000  //number of chi^2 tests

using namespace std;

int main (int argc, char *argv[]){
    
    //per-block iterations
    const int L = M/N;
    
    //open output files
    if(argc!=4)
    {
        cout << "Usage: ./main <output_mean> <output_variance> <output_chi2>" << endl;
        exit(1);
    }
    ofstream fout_mean(argv[1]);
    ofstream fout_var(argv[2]);
    ofstream fout_chi(argv[3]);
    
    //initialize random generator
    Random rnd;
    InitRandomGenerator(rnd);

    int i,j;
    double num;
    double block_mean, means_sum=0, meanssquared_sum=0, st_var_mean=0, mean, st_unc_mean=0;
    double block_var, vars_sum=0, varssquared_sum=0, st_var_var=0, var, st_unc_sd=0;
    
    //computing mean, variance and their uncertainty using block averaging
    for(i=0;i<N;i++) //for each block
    {
        //extract and sum L random numbers
        block_mean=0;
        block_var = 0;
        for(j=0;j<L;j++)
        {
            num = rnd.Rannyu();
            block_mean += num/L;
            block_var += pow(num -0.5, 2)/L;
        }
        
        //mean computation (1.1 part of the execise)
            //means_sum accumulates means of blocks from 0 to i
            means_sum += block_mean;
            //mean is the best estimate up to this block
            mean = means_sum/(i+1);
            
            //meanssquared_sum accumulates squared means
            meanssquared_sum += pow(block_mean, 2);

            //compute statistical uncertainty of mean, requires i>0
            st_var_mean = meanssquared_sum/(i+1) - pow(mean, 2);
            if(i>0)
                st_unc_mean = sqrt(st_var_mean/(i));
            
            //output of mean computed at block i with its statistical uncertainty
            fout_mean << mean << " " << st_unc_mean << endl;
        
        //variance computation (1.2 part of the exercise)
            //vars_sum accumulates variances of blocks from 0 to i
            vars_sum += block_var;
            //var is the best etimate of the variance up to this block
            var = vars_sum/(i+1);
            
            //varssquared_sum accumulates squared variances used then to compute 
            //statistical uncertainty
            varssquared_sum += pow(block_var, 2);
            
            //compute statistical uncertainty of variance
            st_var_var = varssquared_sum/(i+1) - pow(var, 2);
            if(i>0)
                st_unc_sd = sqrt(st_var_var/(i));

            //output of variance computed at block i wth its statistical uncertainty
            fout_var <<var<< " " << st_unc_sd << endl;
    }
    
    //close files used
    fout_mean.close();
    fout_var.close();
    
    //chi^2 test (1.3 part of the exercise)
    double rn, chi2;
    //vector c keep trace of observed frequencies in each subinterval
    int o[K], t, pos;
    //do N_TEST different chi^2 tests
    for(i=0;i<N_TEST;i++)
    {
        
        for(int l=0;l<K;l++)
            o[l]=0;
        
        for(j=0;j<R;j++)
        {
            //generate random number in [0;1)
            rn = rnd.Rannyu();
            
            //determine in which subinterval rn lies
            //pos is an int so it get truncated as needed
            pos = rn*K; 
            o[pos]++;
        }
        
        //compute chi^2 with observed frequencies
        chi2 = 0;
        for(t=0;t<K;t++)
            chi2 += pow(o[t] - 1.*R/K, 2)/(1.*R/K);
        
        //output computed value on file
        fout_chi << chi2 << endl;
    }

    //close chi^2 output file
    fout_chi.close();

    return 0;
}


